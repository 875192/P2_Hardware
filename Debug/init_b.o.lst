   1              	# 1 "../init_b.asm"
   1              	.text
   0              	
   0              	
   0              	
   2              	
   3              	#        ENTRY                  /*  mark the first instruction to call */
   4              	.global start
   5              	
   6              	start:
   7              	.arm    /* indicates that we are using the ARM instruction set */
   8              	
   9              	#------standard initial code
  10              	# --- Setup interrupt / exception vectors
  11 0000 FFFFFFEA 	      B       Reset_Handler
  12              	/* In this version we do not use the following handlers */
  13              	################################################################################
  14              	#-----------Undefined_Handler:
  15              	#      B       Undefined_Handler
  16              	#----------SWI_Handler:
  17              	#      B       SWI_Handler
  18              	#----------Prefetch_Handler:
  19              	#      B       Prefetch_Handler
  20              	#----------Abort_Handler:
  21              	#      B       Abort_Handler
  22              	#         NOP      /* Reserved vector */
  23              	#----------IRQ_Handler:
  24              	#      B       IRQ_Handler
  25              	#----------FIQ_Handler:
  26              	#      B       FIQ_Handler
  27              	
  28              	################################################################################
  29              	# Reset Handler:
  30              	# the processor starts executing this code after system reset
  31              	################################################################################
  32              	Reset_Handler:
  33              	#
  34 0004 01D9A0E3 	        MOV     sp, #0x4000      /*  set up stack pointer (r13) */
  35              	#
  36              	#  USING A .C FUNCTION
  37              	#
  38              	# FUNCTION CALL the parameters are stored in r0 and r1
  39              	# If there are 4 or less parameters when calling a C function the compiler
  40              	# assumes that they have been stored in r0-r3.
  41              	# If there are more parameters you have to store them in the data stack
  42              	# using the stack pointer
  43              	
  44              	.extern     main
  45 0008 94549FE5 	        ldr         r5, = main
  46 000c 0FE0A0E1 	        mov         lr, pc
  47 0010 15FF2FE1 	        bx          r5
  48              	
  49              	stop:
  50 0014 FEFFFFEA 	        B       stop        /*  end of program */
  51              	
  52              	################################################################################
  53              	# IMPLEMENTACIÓN ARM DE candidatos_propagar_arm
  54              	#
  55              	# Función: candidatos_propagar_arm
  56              	# Parámetros:
  57              	#   r0: CELDA cuadricula[NUM_FILAS][NUM_COLUMNAS] - puntero base cuadrícula
  58              	#   r1: uint8_t fila - fila de la celda a propagar (0-8)
  59              	#   r2: uint8_t columna - columna de la celda a propagar (0-8)
  60              	#
  61              	# La función lee el valor de la celda y propaga eliminando ese candidato
  62              	# de todas las celdas en:
  63              	# - La misma fila
  64              	# - La misma columna
  65              	# - La misma región 3x3
  66              	################################################################################
  67              	.global candidatos_propagar_arm
  68              	
  69              	candidatos_propagar_arm:
  70              	    # Preservar registros
  71 0018 F04F2DE9 	    STMDB   SP!, {r4-r10, fp, LR}
  72 001c 18B08DE2 	    ADD     fp, SP, #(4*7-4)    @ FP ← dirección base del marco (7 registros: r4-r10)
  73              	
  74              	    # ========== ASIGNACIÓN DE REGISTROS ==========
  75              	    # REGISTROS CRÍTICOS (no reutilizables):
  76              	    # r0 = puntero base cuadrícula (INMUTABLE)
  77              	    # r1 = fila (parámetro)
  78              	    # r2 = columna (parámetro)
  79              	    # r3 = valor a propagar (calculado)
  80              	    # r4 = NUM_FILAS = 9 (constante)
  81              	    # r5 = NUM_COLUMNAS = 16 (constante)
  82              	    # r10 = máscara para eliminar candidato (calculada)
  83              	    #
  84              	    # REGISTROS REUTILIZABLES:
  85              	    # r6 = contador j (bucle fila / región)
  86              	    # r7 = contador i (bucle columna / región)
  87              	    # r8 = dirección de celda temporal
  88              	    # r9 = valor de celda temporal
  89              	
  90              	    # Inicializar constantes
  91 0020 0940A0E3 	    MOV     r4, #9          // NUM_FILAS
  92 0024 1050A0E3 	    MOV     r5, #16         // NUM_COLUMNAS (9 + 7 padding)
  93              	
  94              	    # Leer valor de la celda actual: cuadricula[fila][columna]
  95 0028 912528E0 	    MLA     r8, r1, r5, r2  // r8 = fila * NUM_COLUMNAS + columna
  96 002c 8880A0E1 	    MOV     r8, r8, LSL #1  // r8 *= 2 (sizeof CELDA)
  97 0030 088080E0 	    ADD     r8, r0, r8      // r8 = dirección de cuadricula[fila][columna]
  98 0034 B030D8E1 	    LDRH    r3, [r8]        // r3 = cuadricula[fila][columna]
  99 0038 0F3003E2 	    AND     r3, r3, #0x0F   // r3 = valor (bits 3-0)
 100              	
 101              	    # Si valor es 0, no hay nada que propagar
 102 003c 000053E3 	    CMP     r3, #0
 103 0040 3800000A 	    BEQ     propagar_fin
 104              	
 105              	    # Calcular máscara para eliminar candidato: (1 << (7 + valor - 1))
 106 0044 079083E2 	    ADD     r9, r3, #7      // r9 = 7 + valor (BIT_CANDIDATOS = 7)
 107 0048 019049E2 	    SUB     r9, r9, #1      // r9 = 7 + valor - 1
 108 004c 01A0A0E3 	    MOV     r10, #1         // r10 = 1
 109 0050 1AA9A0E1 	    MOV     r10, r10, LSL r9 // r10 = máscara para eliminar candidato
 110              	
 111              	    # ===== RECORRER FILA =====
 112 0054 0060A0E3 	    MOV     r6, #0          // j = 0
 113              	
 114              	bucle_fila:
 115 0058 040056E1 	    CMP     r6, r4          // comparar j con NUM_FILAS
 116 005c 070000AA 	    BGE     fin_fila        // si j >= NUM_FILAS, terminar
 117              	
 118              	    # Calcular dirección: cuadricula[fila][j]
 119 0060 916528E0 	    MLA     r8, r1, r5, r6  // r8 = fila * NUM_COLUMNAS + j
 120 0064 8880A0E1 	    MOV     r8, r8, LSL #1  // r8 *= 2 (sizeof CELDA)
 121 0068 088080E0 	    ADD     r8, r0, r8      // r8 = dirección de cuadricula[fila][j]
 122              	
 123              	    # Leer valor de la celda
 124 006c B090D8E1 	    LDRH    r9, [r8]        // r9 = cuadricula[fila][j]
 125              	
 126              	    # Eliminar candidato: celda |= máscara
 127 0070 0A9089E1 	    ORR     r9, r9, r10     // r9 |= máscara
 128 0074 B090C8E1 	    STRH    r9, [r8]        // guardar celda modificada
 129              	
 130              	siguiente_fila:
 131 0078 016086E2 	    ADD     r6, r6, #1      // j++
 132 007c F5FFFFEA 	    B       bucle_fila
 133              	
 134              	fin_fila:
 135              	    # ===== RECORRER COLUMNA =====
 136 0080 0070A0E3 	    MOV     r7, #0          // i = 0
 137              	
 138              	bucle_columna:
 139 0084 040057E1 	    CMP     r7, r4          // comparar i con NUM_FILAS, evitamos padding
 140 0088 070000AA 	    BGE     fin_columna     // si i >= NUM_FILAS, terminar
 141              	
 142              	    # Calcular dirección: cuadricula[i][columna]
 143 008c 972528E0 	    MLA     r8, r7, r5, r2  // r8 = i * NUM_COLUMNAS + columna
 144 0090 8880A0E1 	    MOV     r8, r8, LSL #1  // r8 *= 2 (sizeof CELDA)
 145 0094 088080E0 	    ADD     r8, r0, r8      // r8 = dirección de cuadricula[i][columna]
 146              	
 147              	    # Leer valor de la celda
 148 0098 B090D8E1 	    LDRH    r9, [r8]        // r9 = cuadricula[i][columna]
 149              	
 150              	    # Eliminar candidato: celda |= máscara
 151 009c 0A9089E1 	    ORR     r9, r9, r10     // r9 |= máscara
 152 00a0 B090C8E1 	    STRH    r9, [r8]        // guardar celda modificada
 153              	
 154              	siguiente_columna:
 155 00a4 017087E2 	    ADD     r7, r7, #1      // i++
 156 00a8 F5FFFFEA 	    B       bucle_columna
 157              	
 158              	fin_columna:
 159              	    # ===== RECORRER REGIÓN 3x3 =====
 160              	    # Implementar lookup table: init_region[9] = {0, 0, 0, 3, 3, 3, 6, 6, 6}
 161              	    # Calcular init_i usando lookup table
 162 00ac 030051E3 	    CMP     r1, #3
 163 00b0 0070A0B3 	    MOVLT   r7, #0          // si fila < 3, init_i = 0
 164 00b4 0370A0A3 	    MOVGE   r7, #3          // si fila >= 3, init_i = 3
 165 00b8 060051E3 	    CMP     r1, #6
 166 00bc 0670A0A3 	    MOVGE   r7, #6          // si fila >= 6, init_i = 6
 167              	
 168              	    # Calcular init_j usando lookup table
 169 00c0 030052E3 	    CMP     r2, #3
 170 00c4 0060A0B3 	    MOVLT   r6, #0          // si columna < 3, init_j = 0
 171 00c8 0360A0A3 	    MOVGE   r6, #3          // si columna >= 3, init_j = 3
 172 00cc 060052E3 	    CMP     r2, #6
 173 00d0 0660A0A3 	    MOVGE   r6, #6          // si columna >= 6, init_j = 6
 174              	
 175              	    # r7 = init_i, r6 = init_j
 176              	    # Bucle región: for (i = init_i; i < init_i + 3; i++)
 177 00d4 033087E2 	    ADD     r3, r7, #3      // r3 = init_i + 3 (reutilizar r3)
 178              	
 179              	bucle_region_i:
 180 00d8 030057E1 	    CMP     r7, r3          // comparar i con init_i + 3
 181 00dc 110000AA 	    BGE     fin_region      // si i >= init_i + 3, terminar
 182              	
 183              	    # Bucle región: for (j = init_j; j < init_j + 3; j++)
 184              	    # Recalcular init_j para bucle interno
 185 00e0 030052E3 	    CMP     r2, #3
 186 00e4 0060A0B3 	    MOVLT   r6, #0
 187 00e8 0360A0A3 	    MOVGE   r6, #3
 188 00ec 060052E3 	    CMP     r2, #6
 189 00f0 0660A0A3 	    MOVGE   r6, #6
 190              	    
 191 00f4 039086E2 	    ADD     r9, r6, #3      // r9 = init_j + 3
 192              	
 193              	bucle_region_j:
 194 00f8 090056E1 	    CMP     r6, r9          // comparar j con init_j + 3
 195 00fc 070000AA 	    BGE     fin_region_j    // si j >= init_j + 3, terminar bucle j
 196              	
 197              	    # Calcular dirección: cuadricula[i][j]
 198 0100 976528E0 	    MLA     r8, r7, r5, r6  // r8 = i * NUM_COLUMNAS + j
 199 0104 8880A0E1 	    MOV     r8, r8, LSL #1  // r8 *= 2 (sizeof CELDA)
 200 0108 088080E0 	    ADD     r8, r0, r8      // r8 = dirección de cuadricula[i][j]
 201              	
 202              	    # Leer valor de la celda
 203 010c B040D8E1 	    LDRH    r4, [r8]        // r4 = cuadricula[i][j] (reutilizar r4)
 204              	
 205              	    # Eliminar candidato: celda |= máscara
 206 0110 0A4084E1 	    ORR     r4, r4, r10     // r4 |= máscara
 207 0114 B040C8E1 	    STRH    r4, [r8]        // guardar celda modificada
 208              	
 209              	siguiente_region_j:
 210 0118 016086E2 	    ADD     r6, r6, #1      // j++
 211 011c F5FFFFEA 	    B       bucle_region_j
 212              	
 213              	fin_region_j:
 214 0120 017087E2 	    ADD     r7, r7, #1      // i++
 215 0124 EBFFFFEA 	    B       bucle_region_i
 216              	
 217              	fin_region:
 218              	propagar_fin:
 219              	    # Restaurar registros y retornar
 220 0128 F04FBDE8 	    LDMIA   SP!, {r4-r10, fp, LR}
 221 012c 1EFF2FE1 	    BX      LR
 222              	
 223              	
 224              	################################################################################
 225              	# IMPLEMENTACIÓN ARM DE candidatos_actualizar_arm_arm
 226              	#
 227              	# Función: candidatos_actualizar_arm_arm
 228              	# Parámetros:
 229              	#   r0: CELDA cuadricula[NUM_FILAS][NUM_COLUMNAS] - puntero base cuadrícula
 230              	#
 231              	# Comportamiento:
 232              	# FASE 1: Recorre toda la cuadrícula y para cada celda:
 233              	#         - Limpia bits candidatos [15,7] poniendo todos a 0
 234              	#         - Si valor=0, incrementa contador de celdas vacías
 235              	# FASE 2: Recorre toda la cuadrícula y para cada celda con valor (valor≠0):
 236              	#         - Llama a candidatos_propagar_arm para eliminar candidatos
 237              	#
 238              	# Retorna: número de celdas vacías (en r0)
 239              	################################################################################
 240              	.global candidatos_actualizar_arm_arm
 241              	
 242              	candidatos_actualizar_arm_arm:
 243              	    # Preservar registros y configurar frame pointer
 244 0130 F04F2DE9 	    STMDB   SP!, {r4-r10, fp, LR}
 245 0134 18B08DE2 	    ADD     fp, SP, #(4*7-4)    @ FP ← dirección base del marco (7 registros: r4-r10)
 246 0138 08D04DE2 	    SUB     SP, SP, #8      // Reservar espacio para 2 variables locales (i, j)
 247              	
 248              	    # ========== ASIGNACIÓN DE REGISTROS ==========
 249              	    # REGISTROS CRÍTICOS (no reutilizables):
 250              	    # r4 = puntero base cuadrícula (INMUTABLE)
 251              	    # r5 = NUM_FILAS = 9 (constante)
 252              	    # r6 = NUM_COLUMNAS = 16 (constante)
 253              	    # r7 = máscara para limpiar candidatos = 0x007F (constante)
 254              	    # r8 = contador de celdas vacías
 255              	    # 
 256              	    # REGISTROS REUTILIZABLES:
 257              	    # r9 = contador i (filas)
 258              	    # r10 = contador j (columnas)
 259              	    # r0,r1,r2,r3 = direcciones, valores temporales
 260              	
 261              	    # Inicializar constantes
 262 013c 0040A0E1 	    MOV     r4, r0          // r4 = puntero base cuadrícula
 263 0140 0950A0E3 	    MOV     r5, #9          // r5 = NUM_FILAS
 264 0144 1060A0E3 	    MOV     r6, #16         // r6 = NUM_COLUMNAS (9 + 7 padding)
 265 0148 7F70A0E3 	    MOV     r7, #0x007F     // r7 = máscara para limpiar candidatos (preservar bits 6-0)
 266 014c 0080A0E3 	    MOV     r8, #0          // r8 = contador celdas vacías
 267              	
 268              	    # ===== FASE 1: LIMPIAR CANDIDATOS DE TODAS LAS CELDAS Y CONTAR CELDAS VACÍAS =====
 269 0150 0090A0E3 	    MOV     r9, #0          // r9 = i (contador filas)
 270              	
 271              	fase1_arm_arm_bucle_i:
 272 0154 050059E1 	    CMP     r9, r5          // comparar i con NUM_FILAS
 273 0158 0F0000AA 	    BGE     fase1_arm_arm_fin // si i >= NUM_FILAS, terminar fase 1
 274              	
 275 015c 00A0A0E3 	    MOV     r10, #0         // r10 = j (contador columnas)
 276              	
 277              	fase1_arm_arm_bucle_j:
 278 0160 05005AE1 	    CMP     r10, r5         // comparar j con NUM_FILAS (solo primeras 9 columnas)
 279 0164 0A0000AA 	    BGE     fase1_arm_arm_fin_j // si j >= NUM_FILAS, terminar bucle j
 280              	
 281              	    # Calcular dirección: cuadricula[i][j]
 282 0168 99A620E0 	    MLA     r0, r9, r6, r10 // r0 = i * NUM_COLUMNAS + j
 283 016c 8000A0E1 	    MOV     r0, r0, LSL #1  // r0 *= 2 (sizeof CELDA)
 284 0170 000084E0 	    ADD     r0, r4, r0      // r0 = dirección de cuadricula[i][j]
 285              	
 286              	    # Leer celda y limpiar candidatos de TODAS las celdas
 287 0174 B010D0E1 	    LDRH    r1, [r0]        // r1 = cuadricula[i][j]
 288 0178 071001E0 	    AND     r1, r1, r7      // r1 &= 0x007F (limpiar bits candidatos 15-7)
 289 017c B010C0E1 	    STRH    r1, [r0]        // guardar celda modificada
 290              	    
 291              	    # Si valor es 0, incrementar contador de celdas vacías
 292 0180 0F2001E2 	    AND     r2, r1, #0x0F   // r2 = valor de la celda (bits 3-0)
 293 0184 000052E3 	    CMP     r2, #0          // ¿valor == 0?
 294 0188 01808802 	    ADDEQ   r8, r8, #1      // si sí, celdas_vacias++
 295              	
 296              	fase1_arm_arm_siguiente_j:
 297 018c 01A08AE2 	    ADD     r10, r10, #1    // j++
 298 0190 F2FFFFEA 	    B       fase1_arm_arm_bucle_j
 299              	
 300              	fase1_arm_arm_fin_j:
 301 0194 019089E2 	    ADD     r9, r9, #1      // i++
 302 0198 EDFFFFEA 	    B       fase1_arm_arm_bucle_i
 303              	
 304              	fase1_arm_arm_fin:
 305              	    # ===== FASE 2: PROPAGAR VALORES DE CELDAS NO VACÍAS =====
 306 019c 0090A0E3 	    MOV     r9, #0          // r9 = i (contador filas)
 307              	
 308              	fase2_arm_arm_bucle_i:
 309 01a0 050059E1 	    CMP     r9, r5          // comparar i con NUM_FILAS
 310 01a4 150000AA 	    BGE     fase2_arm_arm_fin // si i >= NUM_FILAS, terminar fase 2
 311              	
 312 01a8 00A0A0E3 	    MOV     r10, #0         // r10 = j (contador columnas)
 313              	
 314              	fase2_arm_arm_bucle_j:
 315 01ac 05005AE1 	    CMP     r10, r5         // comparar j con NUM_FILAS (solo primeras 9 columnas)
 316 01b0 100000AA 	    BGE     fase2_arm_arm_fin_j // si j >= NUM_FILAS, terminar bucle j
 317              	
 318              	    # Calcular dirección: cuadricula[i][j]
 319 01b4 99A620E0 	    MLA     r0, r9, r6, r10 // r0 = i * NUM_COLUMNAS + j
 320 01b8 8000A0E1 	    MOV     r0, r0, LSL #1  // r0 *= 2 (sizeof CELDA)
 321 01bc 000084E0 	    ADD     r0, r4, r0      // r0 = dirección de cuadricula[i][j]
 322              	
 323              	    # Procesar celda
 324 01c0 B010D0E1 	    LDRH    r1, [r0]        // r1 = cuadricula[i][j]
 325 01c4 0F2001E2 	    AND     r2, r1, #0x0F   // r2 = valor de la celda (bits 3-0)
 326              	
 327              	    # Si celda está vacía (valor == 0), saltar
 328 01c8 000052E3 	    CMP     r2, #0
 329 01cc 0700000A 	    BEQ     fase2_arm_arm_siguiente_j
 330              	
 331              	    # Celda con valor: llamar a candidatos_propagar_arm
 332              	    # Guardar estado actual usando frame pointer
 333 01d0 04900BE5 	    STR     r9, [fp, #-4]   // guardar i (fila)
 334 01d4 08A00BE5 	    STR     r10, [fp, #-8]  // guardar j (columna)
 335              	    
 336              	    # Preparar parámetros para la llamada
 337 01d8 0400A0E1 	    MOV     r0, r4          // r0 = puntero base cuadrícula
 338 01dc 0910A0E1 	    MOV     r1, r9          // r1 = fila (i)
 339 01e0 0A20A0E1 	    MOV     r2, r10         // r2 = columna (j)
 340              	
 341              	    # Llamar a candidatos_propagar_arm
 342 01e4 FEFFFFEB 	    BL      candidatos_propagar_arm
 343              	
 344              	    # Restaurar estado desde frame pointer
 345 01e8 04901BE5 	    LDR     r9, [fp, #-4]   // restaurar i (fila)
 346 01ec 08A01BE5 	    LDR     r10, [fp, #-8]  // restaurar j (columna)
 347              	
 348              	fase2_arm_arm_siguiente_j:
 349 01f0 01A08AE2 	    ADD     r10, r10, #1    // j++
 350 01f4 ECFFFFEA 	    B       fase2_arm_arm_bucle_j
 351              	
 352              	fase2_arm_arm_fin_j:
 353 01f8 019089E2 	    ADD     r9, r9, #1      // i++
 354 01fc E7FFFFEA 	    B       fase2_arm_arm_bucle_i
 355              	
 356              	fase2_arm_arm_fin:
 357              	    # Preparar valor de retorno
 358 0200 0800A0E1 	    MOV     r0, r8          // r0 = celdas_vacias (valor de retorno)
 359              	
 360              	    # Restaurar pila y registros, luego retornar
 361 0204 08D08DE2 	    ADD     SP, SP, #8      // Liberar espacio de variables locales
 362 0208 F04FBDE8 	    LDMIA   SP!, {r4-r10, fp, LR}
 363 020c 1EFF2FE1 	    BX      LR
 364              	
 365              	################################################################################
 366              	# IMPLEMENTACIÓN ARM DE candidatos_actualizar_arm_c
 367              	#
 368              	# Función: candidatos_actualizar_arm_c
 369              	# Parámetros:
 370              	#   r0: CELDA cuadricula[NUM_FILAS][NUM_COLUMNAS] - puntero base cuadrícula
 371              	#
 372              	# Comportamiento:
 373              	# FASE 1: Recorre toda la cuadrícula y para cada celda:
 374              	#         - Limpia bits candidatos [15,7] poniendo todos a 0
 375              	#         - Si valor=0, incrementa contador de celdas vacías
 376              	# FASE 2: Recorre toda la cuadrícula y para cada celda con valor (valor≠0):
 377              	#         - Llama a candidatos_propagar_c (función C) para eliminar candidatos
 378              	#
 379              	# Retorna: número de celdas vacías (en r0)
 380              	################################################################################
 381              	.global candidatos_actualizar_arm_c
 382              	
 383              	candidatos_actualizar_arm_c:
 384              	    # Preservar registros y configurar frame pointer
 385 0210 F04F2DE9 	    STMDB   SP!, {r4-r10, fp, LR}
 386 0214 18B08DE2 	    ADD     fp, SP, #(4*7-4)    @ FP ← dirección base del marco (7 registros: r4-r10)
 387 0218 08D04DE2 	    SUB     SP, SP, #8      // Reservar espacio para 2 variables locales (i, j)
 388              	
 389              	    # ========== ASIGNACIÓN DE REGISTROS ==========
 390              	    # REGISTROS CRÍTICOS (no reutilizables):
 391              	    # r4 = puntero base cuadrícula (INMUTABLE)
 392              	    # r5 = NUM_FILAS = 9 (constante)
 393              	    # r6 = NUM_COLUMNAS = 16 (constante)
 394              	    # r7 = máscara para limpiar candidatos = 0x007F (constante)
 395              	    # r8 = contador de celdas vacías
 396              	    # 
 397              	    # REGISTROS REUTILIZABLES:
 398              	    # r9 = contador i (filas)
 399              	    # r10 = contador j (columnas)
 400              	    # r0,r1,r2,r3 = direcciones, valores temporales
 401              	
 402              	    # Inicializar constantes
 403 021c 0040A0E1 	    MOV     r4, r0          // r4 = puntero base cuadrícula
 404 0220 0950A0E3 	    MOV     r5, #9          // r5 = NUM_FILAS
 405 0224 1060A0E3 	    MOV     r6, #16         // r6 = NUM_COLUMNAS (9 + 7 padding)
 406 0228 7F70A0E3 	    MOV     r7, #0x007F     // r7 = máscara para limpiar candidatos (preservar bits 6-0)
 407 022c 0080A0E3 	    MOV     r8, #0          // r8 = contador celdas vacías
 408              	
 409              	    # ===== FASE 1: LIMPIAR CANDIDATOS DE TODAS LAS CELDAS Y CONTAR CELDAS VACÍAS =====
 410 0230 0090A0E3 	    MOV     r9, #0          // r9 = i (contador filas)
 411              	
 412              	fase1_arm_c_bucle_i:
 413 0234 050059E1 	    CMP     r9, r5          // comparar i con NUM_FILAS
 414 0238 0F0000AA 	    BGE     fase1_arm_c_fin // si i >= NUM_FILAS, terminar fase 1
 415              	
 416 023c 00A0A0E3 	    MOV     r10, #0         // r10 = j (contador columnas)
 417              	
 418              	fase1_arm_c_bucle_j:
 419 0240 05005AE1 	    CMP     r10, r5         // comparar j con NUM_FILAS (solo primeras 9 columnas)
 420 0244 0A0000AA 	    BGE     fase1_arm_c_fin_j // si j >= NUM_FILAS, terminar bucle j
 421              	
 422              	    # Calcular dirección: cuadricula[i][j]
 423 0248 99A620E0 	    MLA     r0, r9, r6, r10 // r0 = i * NUM_COLUMNAS + j
 424 024c 8000A0E1 	    MOV     r0, r0, LSL #1  // r0 *= 2 (sizeof CELDA)
 425 0250 000084E0 	    ADD     r0, r4, r0      // r0 = dirección de cuadricula[i][j]
 426              	
 427              	    # Leer celda y limpiar candidatos de TODAS las celdas
 428 0254 B010D0E1 	    LDRH    r1, [r0]        // r1 = cuadricula[i][j]
 429 0258 071001E0 	    AND     r1, r1, r7      // r1 &= 0x007F (limpiar bits candidatos 15-7)
 430 025c B010C0E1 	    STRH    r1, [r0]        // guardar celda modificada
 431              	    
 432              	    # Si valor es 0, incrementar contador de celdas vacías
 433 0260 0F2001E2 	    AND     r2, r1, #0x0F   // r2 = valor de la celda (bits 3-0)
 434 0264 000052E3 	    CMP     r2, #0          // ¿valor == 0?
 435 0268 01808802 	    ADDEQ   r8, r8, #1      // si sí, celdas_vacias++
 436              	
 437              	fase1_arm_c_siguiente_j:
 438 026c 01A08AE2 	    ADD     r10, r10, #1    // j++
 439 0270 F2FFFFEA 	    B       fase1_arm_c_bucle_j
 440              	
 441              	fase1_arm_c_fin_j:
 442 0274 019089E2 	    ADD     r9, r9, #1      // i++
 443 0278 EDFFFFEA 	    B       fase1_arm_c_bucle_i
 444              	
 445              	fase1_arm_c_fin:
 446              	    # ===== FASE 2: PROPAGAR VALORES DE CELDAS NO VACÍAS =====
 447 027c 0090A0E3 	    MOV     r9, #0          // r9 = i (contador filas)
 448              	
 449              	fase2_arm_c_bucle_i:
 450 0280 050059E1 	    CMP     r9, r5          // comparar i con NUM_FILAS
 451 0284 150000AA 	    BGE     fase2_arm_c_fin // si i >= NUM_FILAS, terminar fase 2
 452              	
 453 0288 00A0A0E3 	    MOV     r10, #0         // r10 = j (contador columnas)
 454              	
 455              	fase2_arm_c_bucle_j:
 456 028c 05005AE1 	    CMP     r10, r5         // comparar j con NUM_FILAS (solo primeras 9 columnas)
 457 0290 100000AA 	    BGE     fase2_arm_c_fin_j // si j >= NUM_FILAS, terminar bucle j
 458              	
 459              	    # Calcular dirección: cuadricula[i][j]
 460 0294 99A620E0 	    MLA     r0, r9, r6, r10 // r0 = i * NUM_COLUMNAS + j
 461 0298 8000A0E1 	    MOV     r0, r0, LSL #1  // r0 *= 2 (sizeof CELDA)
 462 029c 000084E0 	    ADD     r0, r4, r0      // r0 = dirección de cuadricula[i][j]
 463              	
 464              	    # Procesar celda
 465 02a0 B010D0E1 	    LDRH    r1, [r0]        // r1 = cuadricula[i][j]
 466 02a4 0F2001E2 	    AND     r2, r1, #0x0F   // r2 = valor de la celda (bits 3-0)
 467              	
 468              	    # Si celda está vacía (valor == 0), saltar
 469 02a8 000052E3 	    CMP     r2, #0
 470 02ac 0700000A 	    BEQ     fase2_arm_c_siguiente_j
 471              	
 472              	    # Celda con valor: llamar a candidatos_propagar_c
 473              	    # Guardar estado actual usando frame pointer
 474 02b0 04900BE5 	    STR     r9, [fp, #-4]   // guardar i (fila)
 475 02b4 08A00BE5 	    STR     r10, [fp, #-8]  // guardar j (columna)
 476              	    
 477              	    # Preparar parámetros para la llamada
 478 02b8 0400A0E1 	    MOV     r0, r4          // r0 = puntero base cuadrícula
 479 02bc 0910A0E1 	    MOV     r1, r9          // r1 = fila (i)
 480 02c0 0A20A0E1 	    MOV     r2, r10         // r2 = columna (j)
 481              	
 482              	    # Llamar a candidatos_propagar_c (función C)
 483 02c4 FEFFFFEB 	    BL      candidatos_propagar_c
 484              	
 485              	    # Restaurar estado desde frame pointer
 486 02c8 04901BE5 	    LDR     r9, [fp, #-4]   // restaurar i (fila)
 487 02cc 08A01BE5 	    LDR     r10, [fp, #-8]  // restaurar j (columna)
 488              	
 489              	fase2_arm_c_siguiente_j:
 490 02d0 01A08AE2 	    ADD     r10, r10, #1    // j++
 491 02d4 ECFFFFEA 	    B       fase2_arm_c_bucle_j
 492              	
 493              	fase2_arm_c_fin_j:
 494 02d8 019089E2 	    ADD     r9, r9, #1      // i++
 495 02dc E7FFFFEA 	    B       fase2_arm_c_bucle_i
 496              	
 497              	fase2_arm_c_fin:
 498              	    # Preparar valor de retorno
 499 02e0 0800A0E1 	    MOV     r0, r8          // r0 = celdas_vacias (valor de retorno)
 500              	
 501              	    # Restaurar pila y registros, luego retornar
 502 02e4 08D08DE2 	    ADD     SP, SP, #8      // Liberar espacio de variables locales
 503 02e8 F04FBDE8 	    LDMIA   SP!, {r4-r10, fp, LR}
 504 02ec 1EFF2FE1 	    BX      LR
 505              	
 506              	################################################################################
 507              	# IMPLEMENTACIÓN ARM DE candidatos_actualizar_all
 508              	#
 509              	# Función: candidatos_actualizar_all
 510              	# Parámetros:
 511              	#   r0: CELDA cuadricula[NUM_FILAS][NUM_COLUMNAS] - puntero base cuadrícula
 512              	#
 513              	# Comportamiento:
 514              	# FASE 1: Recorre toda la cuadrícula y para cada celda:
 515              	#         - Limpia bits candidatos [15,7] poniendo todos a 0
 516              	#         - Si valor=0, incrementa contador de celdas vacías
 517              	# FASE 2: Recorre toda la cuadrícula y para cada celda con valor (valor≠0):
 518              	#         - Ejecuta código inlineado de candidatos_propagar_arm para eliminar candidatos
 519              	#           (evitando la sobrecarga de llamadas a subrutina)
 520              	#
 521              	# Retorna: número de celdas vacías (en r0)
 522              	################################################################################
 523              	.global candidatos_actualizar_all
 524              	
 525              	candidatos_actualizar_all:
 526              	    # Preservar registros y configurar frame pointer
 527 02f0 F04F2DE9 	    STMDB   SP!, {r4-r10, fp, LR}
 528 02f4 18B08DE2 	    ADD     fp, SP, #(4*7-4)    @ FP ← dirección base del marco (7 registros: r4-r10)
 529 02f8 08D04DE2 	    SUB     SP, SP, #8      // Reservar espacio para 2 variables locales (i, j)
 530              	
 531              	    # ========== ASIGNACIÓN DE REGISTROS ==========
 532              	    # REGISTROS CRÍTICOS (no reutilizables):
 533              	    # r4 = puntero base cuadrícula (INMUTABLE)
 534              	    # r5 = NUM_FILAS = 9 (constante)
 535              	    # r6 = NUM_COLUMNAS = 16 (constante)  
 536              	    # r7 = contador de celdas vacías (CRÍTICO para retorno)
 537              	    # 
 538              	    # REGISTROS REUTILIZABLES:
 539              	    # r8 = contador i principal / contador bucles internos
 540              	    # r9 = contador j principal / direcciones temporales
 541              	    # r10 = dirección celda actual / máscaras temporales / valores temporales
 542              	
 543              	    # Inicializar registros críticos
 544 02fc 0040A0E1 	    MOV     r4, r0          // r4 = puntero base cuadrícula (inmutable)
 545 0300 0950A0E3 	    MOV     r5, #9          // r5 = NUM_FILAS
 546 0304 1060A0E3 	    MOV     r6, #16         // r6 = NUM_COLUMNAS (9 + 7 padding)
 547 0308 0070A0E3 	    MOV     r7, #0          // r7 = contador celdas vacías
 548              	
 549              	    # ===== FASE 1: LIMPIAR CANDIDATOS Y CONTAR CELDAS VACÍAS =====
 550 030c 0080A0E3 	    MOV     r8, #0          // r8 = i (contador filas)
 551              	
 552              	fase1_all_bucle_i:
 553 0310 050058E1 	    CMP     r8, r5          // comparar i con NUM_FILAS
 554 0314 0F0000AA 	    BGE     fase1_all_fin   // si i >= NUM_FILAS, terminar fase 1
 555              	
 556 0318 0090A0E3 	    MOV     r9, #0          // r9 = j (contador columnas)
 557              	
 558              	fase1_all_bucle_j:
 559 031c 050059E1 	    CMP     r9, r5          // comparar j con NUM_FILAS (solo primeras 9 columnas)
 560 0320 0A0000AA 	    BGE     fase1_all_fin_j // si j >= NUM_FILAS, terminar bucle j
 561              	
 562              	    # Calcular dirección: cuadricula[i][j]
 563 0324 98962AE0 	    MLA     r10, r8, r6, r9 // r10 = i * NUM_COLUMNAS + j
 564 0328 8AA0A0E1 	    MOV     r10, r10, LSL #1 // r10 *= 2 (sizeof CELDA)
 565 032c 0AA084E0 	    ADD     r10, r4, r10    // r10 = dirección de cuadricula[i][j]
 566              	
 567              	    # Leer celda y procesar
 568 0330 B000DAE1 	    LDRH    r0, [r10]       // r0 = cuadricula[i][j]
 569              	    
 570              	    # Limpiar bits candidatos [15,7] manteniendo [6,0]
 571 0334 7F0000E2 	    AND     r0, r0, #0x007F // r0 &= 0x007F (limpiar candidatos)
 572 0338 B000CAE1 	    STRH    r0, [r10]       // guardar celda modificada
 573              	    
 574              	    # Si valor es 0, incrementar contador de celdas vacías
 575 033c 0F0000E2 	    AND     r0, r0, #0x0F   // r0 = valor de la celda (bits 3-0)
 576 0340 000050E3 	    CMP     r0, #0          // ¿valor == 0?
 577 0344 01708702 	    ADDEQ   r7, r7, #1      // si sí, celdas_vacias++
 578              	
 579              	fase1_all_siguiente_j:
 580 0348 019089E2 	    ADD     r9, r9, #1      // j++
 581 034c F2FFFFEA 	    B       fase1_all_bucle_j
 582              	
 583              	fase1_all_fin_j:
 584 0350 018088E2 	    ADD     r8, r8, #1      // i++
 585 0354 EDFFFFEA 	    B       fase1_all_bucle_i
 586              	
 587              	fase1_all_fin:
 588              	    # ===== FASE 2: PROPAGAR VALORES DE CELDAS NO VACÍAS =====
 589 0358 0080A0E3 	    MOV     r8, #0          // r8 = i (contador filas principales)
 590              	
 591              	fase2_all_bucle_i:
 592 035c 050058E1 	    CMP     r8, r5          // comparar i con NUM_FILAS
 593 0360 4B0000AA 	    BGE     fase2_all_fin   // si i >= NUM_FILAS, terminar fase 2
 594              	
 595 0364 0090A0E3 	    MOV     r9, #0          // r9 = j (contador columnas principales)
 596              	
 597              	fase2_all_bucle_j:
 598 0368 050059E1 	    CMP     r9, r5          // comparar j con NUM_FILAS (solo primeras 9 columnas)
 599 036c 460000AA 	    BGE     fase2_all_fin_j // si j >= NUM_FILAS, terminar bucle j
 600              	
 601              	    # Calcular dirección: cuadricula[i][j]
 602 0370 98962AE0 	    MLA     r10, r8, r6, r9 // r10 = i * NUM_COLUMNAS + j
 603 0374 8AA0A0E1 	    MOV     r10, r10, LSL #1 // r10 *= 2 (sizeof CELDA)
 604 0378 0AA084E0 	    ADD     r10, r4, r10    // r10 = dirección de cuadricula[i][j]
 605              	
 606              	    # Leer valor de la celda
 607 037c B000DAE1 	    LDRH    r0, [r10]       // r0 = cuadricula[i][j]
 608 0380 0F0000E2 	    AND     r0, r0, #0x0F   // r0 = valor de la celda (bits 3-0)
 609              	
 610              	    # Si celda está vacía (valor == 0), saltar propagación
 611 0384 000050E3 	    CMP     r0, #0
 612 0388 3D00000A 	    BEQ     fase2_all_siguiente_j
 613              	
 614              	    # ===== CÓDIGO INLINEADO DE CANDIDATOS_PROPAGAR =====
 615              	    # Variables actuales: r8=fila, r9=columna, r0=valor
 616              	    # Registros disponibles para reutilizar: r1,r2,r3
 617              	    
 618              	    # Calcular máscara para eliminar candidato: (1 << (7 + valor - 1))
 619 038c 061080E2 	    ADD     r1, r0, #6      // r1 = valor + 6 (7 + valor - 1)
 620 0390 0120A0E3 	    MOV     r2, #1          // r2 = 1
 621 0394 1221A0E1 	    MOV     r2, r2, LSL r1  // r2 = máscara para eliminar candidato
 622              	
 623              	    # ===== PROPAGAR EN FILA (i=r8 fijo, j variable) =====
 624 0398 0010A0E3 	    MOV     r1, #0          // r1 = j_prop (contador columnas para propagación)
 625              	
 626              	propagar_fila:
 627 039c 050051E1 	    CMP     r1, r5          // comparar j_prop con NUM_FILAS
 628 03a0 070000AA 	    BGE     fin_propagar_fila
 629              	
 630              	    # Calcular dirección: cuadricula[fila][j_prop]
 631 03a4 981623E0 	    MLA     r3, r8, r6, r1  // r3 = fila * NUM_COLUMNAS + j_prop
 632 03a8 8330A0E1 	    MOV     r3, r3, LSL #1  // r3 *= 2 (sizeof CELDA)
 633 03ac 033084E0 	    ADD     r3, r4, r3      // r3 = dirección de cuadricula[fila][j_prop]
 634              	
 635              	    # Eliminar candidato: celda |= máscara
 636 03b0 B000D3E1 	    LDRH    r0, [r3]        // r0 = celda actual
 637 03b4 020080E1 	    ORR     r0, r0, r2      // r0 |= máscara
 638 03b8 B000C3E1 	    STRH    r0, [r3]        // guardar celda modificada
 639              	
 640 03bc 011081E2 	    ADD     r1, r1, #1      // j_prop++
 641 03c0 F5FFFFEA 	    B       propagar_fila
 642              	
 643              	fin_propagar_fila:
 644              	    # ===== PROPAGAR EN COLUMNA (j=r9 fijo, i variable) =====
 645 03c4 0010A0E3 	    MOV     r1, #0          // r1 = i_prop (contador filas para propagación)
 646              	
 647              	propagar_columna:
 648 03c8 050051E1 	    CMP     r1, r5          // comparar i_prop con NUM_FILAS
 649 03cc 070000AA 	    BGE     fin_propagar_columna
 650              	
 651              	    # Calcular dirección: cuadricula[i_prop][columna]
 652 03d0 919623E0 	    MLA     r3, r1, r6, r9  // r3 = i_prop * NUM_COLUMNAS + columna
 653 03d4 8330A0E1 	    MOV     r3, r3, LSL #1  // r3 *= 2 (sizeof CELDA)
 654 03d8 033084E0 	    ADD     r3, r4, r3      // r3 = dirección de cuadricula[i_prop][columna]
 655              	
 656              	    # Eliminar candidato: celda |= máscara
 657 03dc B000D3E1 	    LDRH    r0, [r3]        // r0 = celda actual
 658 03e0 020080E1 	    ORR     r0, r0, r2      // r0 |= máscara
 659 03e4 B000C3E1 	    STRH    r0, [r3]        // guardar celda modificada
 660              	
 661 03e8 011081E2 	    ADD     r1, r1, #1      // i_prop++
 662 03ec F5FFFFEA 	    B       propagar_columna
 663              	
 664              	fin_propagar_columna:
 665              	    # ===== PROPAGAR EN REGIÓN 3x3 =====
 666              	    # Calcular init_i = (fila / 3) * 3
 667 03f0 030058E3 	    CMP     r8, #3
 668 03f4 0010A0B3 	    MOVLT   r1, #0          // si fila < 3, init_i = 0
 669 03f8 0310A0A3 	    MOVGE   r1, #3          // si fila >= 3, init_i = 3
 670 03fc 060058E3 	    CMP     r8, #6
 671 0400 0610A0A3 	    MOVGE   r1, #6          // si fila >= 6, init_i = 6
 672              	
 673              	    # Calcular init_j = (columna / 3) * 3
 674 0404 030059E3 	    CMP     r9, #3
 675 0408 0030A0B3 	    MOVLT   r3, #0          // si columna < 3, init_j = 0
 676 040c 0330A0A3 	    MOVGE   r3, #3          // si columna >= 3, init_j = 3
 677 0410 060059E3 	    CMP     r9, #6
 678 0414 0630A0A3 	    MOVGE   r3, #6          // si columna >= 6, init_j = 6
 679              	
 680              	    # Guardar variables en pila usando frame pointer
 681              	    # fp-4 = init_i, fp-8 = init_j, fp-12 = end_i, fp-16 = end_j, fp-20 = máscara
 682 0418 04100BE5 	    STR     r1, [fp, #-4]   // guardar init_i
 683 041c 08300BE5 	    STR     r3, [fp, #-8]   // guardar init_j
 684 0420 030081E2 	    ADD     r0, r1, #3      // r0 = end_i
 685 0424 0C000BE5 	    STR     r0, [fp, #-12]  // guardar end_i
 686 0428 030083E2 	    ADD     r0, r3, #3      // r0 = end_j
 687 042c 10000BE5 	    STR     r0, [fp, #-16]  // guardar end_j
 688 0430 14200BE5 	    STR     r2, [fp, #-20]  // guardar máscara (r2 contiene la máscara)
 689              	
 690              	    # Bucle región: for (i_reg = init_i; i_reg < end_i; i_reg++)
 691 0434 0110A0E1 	    MOV     r1, r1          // r1 = i_reg = init_i
 692              	
 693              	all_bucle_region_i:
 694 0438 0C001BE5 	    LDR     r0, [fp, #-12]  // cargar end_i
 695 043c 000051E1 	    CMP     r1, r0          // comparar i_reg con end_i
 696 0440 0F0000AA 	    BGE     all_fin_region
 697              	
 698              	    # Bucle región: for (j_reg = init_j; j_reg < end_j; j_reg++)
 699 0444 08301BE5 	    LDR     r3, [fp, #-8]   // cargar init_j
 700 0448 0330A0E1 	    MOV     r3, r3          // r3 = j_reg = init_j
 701              	
 702              	all_bucle_region_j:
 703 044c 10001BE5 	    LDR     r0, [fp, #-16]  // cargar end_j
 704 0450 000053E1 	    CMP     r3, r0          // comparar j_reg con end_j
 705 0454 080000AA 	    BGE     all_fin_region_j
 706              	
 707              	    # Calcular dirección: cuadricula[i_reg][j_reg]
 708 0458 913620E0 	    MLA     r0, r1, r6, r3  // r0 = i_reg * NUM_COLUMNAS + j_reg
 709 045c 8000A0E1 	    MOV     r0, r0, LSL #1  // r0 *= 2 (sizeof CELDA)
 710 0460 000084E0 	    ADD     r0, r4, r0      // r0 = dirección de cuadricula[i_reg][j_reg]
 711              	
 712              	    # Eliminar candidato: celda |= máscara
 713 0464 B0A0D0E1 	    LDRH    r10, [r0]       // r10 = celda actual
 714 0468 14201BE5 	    LDR     r2, [fp, #-20]  // cargar máscara
 715 046c 02A08AE1 	    ORR     r10, r10, r2    // r10 |= máscara
 716 0470 B0A0C0E1 	    STRH    r10, [r0]       // guardar celda modificada
 717              	
 718 0474 013083E2 	    ADD     r3, r3, #1      // j_reg++
 719 0478 F3FFFFEA 	    B       all_bucle_region_j
 720              	
 721              	all_fin_region_j:
 722 047c 011081E2 	    ADD     r1, r1, #1      // i_reg++
 723 0480 ECFFFFEA 	    B       all_bucle_region_i
 724              	
 725              	all_fin_region:
 726              	    # ===== FIN CÓDIGO INLINEADO DE CANDIDATOS_PROPAGAR =====
 727              	
 728              	fase2_all_siguiente_j:
 729 0484 019089E2 	    ADD     r9, r9, #1      // j++
 730 0488 B6FFFFEA 	    B       fase2_all_bucle_j
 731              	
 732              	fase2_all_fin_j:
 733 048c 018088E2 	    ADD     r8, r8, #1      // i++
 734 0490 B1FFFFEA 	    B       fase2_all_bucle_i
 735              	
 736              	fase2_all_fin:
 737              	    # Preparar valor de retorno
 738 0494 0700A0E1 	    MOV     r0, r7          // r0 = celdas_vacias (valor de retorno)
 739              	
 740              	    # Restaurar pila y registros, luego retornar
 741 0498 08D08DE2 	    ADD     SP, SP, #8      // Liberar espacio de variables locales
 742 049c F04FBDE8 	    LDMIA   SP!, {r4-r10, fp, LR}
 743 04a0 1EFF2FE1 	    BX      LR
 744              	
 745 04a4 00000000 	#        END
DEFINED SYMBOLS
       ../init_b.asm:6      .text:00000000 start
       ../init_b.asm:32     .text:00000004 Reset_Handler
       ../init_b.asm:11     .text:00000000 $a
       ../init_b.asm:49     .text:00000014 stop
       ../init_b.asm:69     .text:00000018 candidatos_propagar_arm
       ../init_b.asm:218    .text:00000128 propagar_fin
       ../init_b.asm:114    .text:00000058 bucle_fila
       ../init_b.asm:134    .text:00000080 fin_fila
       ../init_b.asm:130    .text:00000078 siguiente_fila
       ../init_b.asm:138    .text:00000084 bucle_columna
       ../init_b.asm:158    .text:000000ac fin_columna
       ../init_b.asm:154    .text:000000a4 siguiente_columna
       ../init_b.asm:179    .text:000000d8 bucle_region_i
       ../init_b.asm:217    .text:00000128 fin_region
       ../init_b.asm:193    .text:000000f8 bucle_region_j
       ../init_b.asm:213    .text:00000120 fin_region_j
       ../init_b.asm:209    .text:00000118 siguiente_region_j
       ../init_b.asm:242    .text:00000130 candidatos_actualizar_arm_arm
       ../init_b.asm:271    .text:00000154 fase1_arm_arm_bucle_i
       ../init_b.asm:304    .text:0000019c fase1_arm_arm_fin
       ../init_b.asm:277    .text:00000160 fase1_arm_arm_bucle_j
       ../init_b.asm:300    .text:00000194 fase1_arm_arm_fin_j
       ../init_b.asm:296    .text:0000018c fase1_arm_arm_siguiente_j
       ../init_b.asm:308    .text:000001a0 fase2_arm_arm_bucle_i
       ../init_b.asm:356    .text:00000200 fase2_arm_arm_fin
       ../init_b.asm:314    .text:000001ac fase2_arm_arm_bucle_j
       ../init_b.asm:352    .text:000001f8 fase2_arm_arm_fin_j
       ../init_b.asm:348    .text:000001f0 fase2_arm_arm_siguiente_j
       ../init_b.asm:383    .text:00000210 candidatos_actualizar_arm_c
       ../init_b.asm:412    .text:00000234 fase1_arm_c_bucle_i
       ../init_b.asm:445    .text:0000027c fase1_arm_c_fin
       ../init_b.asm:418    .text:00000240 fase1_arm_c_bucle_j
       ../init_b.asm:441    .text:00000274 fase1_arm_c_fin_j
       ../init_b.asm:437    .text:0000026c fase1_arm_c_siguiente_j
       ../init_b.asm:449    .text:00000280 fase2_arm_c_bucle_i
       ../init_b.asm:497    .text:000002e0 fase2_arm_c_fin
       ../init_b.asm:455    .text:0000028c fase2_arm_c_bucle_j
       ../init_b.asm:493    .text:000002d8 fase2_arm_c_fin_j
       ../init_b.asm:489    .text:000002d0 fase2_arm_c_siguiente_j
       ../init_b.asm:525    .text:000002f0 candidatos_actualizar_all
       ../init_b.asm:552    .text:00000310 fase1_all_bucle_i
       ../init_b.asm:587    .text:00000358 fase1_all_fin
       ../init_b.asm:558    .text:0000031c fase1_all_bucle_j
       ../init_b.asm:583    .text:00000350 fase1_all_fin_j
       ../init_b.asm:579    .text:00000348 fase1_all_siguiente_j
       ../init_b.asm:591    .text:0000035c fase2_all_bucle_i
       ../init_b.asm:736    .text:00000494 fase2_all_fin
       ../init_b.asm:597    .text:00000368 fase2_all_bucle_j
       ../init_b.asm:732    .text:0000048c fase2_all_fin_j
       ../init_b.asm:728    .text:00000484 fase2_all_siguiente_j
       ../init_b.asm:626    .text:0000039c propagar_fila
       ../init_b.asm:643    .text:000003c4 fin_propagar_fila
       ../init_b.asm:647    .text:000003c8 propagar_columna
       ../init_b.asm:664    .text:000003f0 fin_propagar_columna
       ../init_b.asm:693    .text:00000438 all_bucle_region_i
       ../init_b.asm:725    .text:00000484 all_fin_region
       ../init_b.asm:702    .text:0000044c all_bucle_region_j
       ../init_b.asm:721    .text:0000047c all_fin_region_j
       ../init_b.asm:745    .text:000004a4 $d
                   .debug_aranges:0000000c $d

UNDEFINED SYMBOLS
main
candidatos_propagar_c
