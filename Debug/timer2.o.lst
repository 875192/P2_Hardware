   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 18, 4
  11              		.file	"timer2.c"
  21              	.Ltext0:
  22              		.file 1 "../timer2.c"
 1879              		.align	2
 1880              	timer2_numero_int:
 1881 0000 00000000 		.space	4
 1882              		.text
 1883              		.align	2
 1884              		.global	timer2_ISR
 1886              	timer2_ISR:
 1887              	.LFB0:
   1:../timer2.c   **** /*********************************************************************************************
   2:../timer2.c   **** * Fichero:		timer2.c
   3:../timer2.c   **** * Autor:		
   4:../timer2.c   **** * Descrip:		Librería de medición de tiempo usando el timer2 del s3c44b0x
   5:../timer2.c   **** * Version:		1.0
   6:../timer2.c   **** *********************************************************************************************/
   7:../timer2.c   **** 
   8:../timer2.c   **** /*--- ficheros de cabecera ---*/
   9:../timer2.c   **** #include "timer2.h"
  10:../timer2.c   **** #include "44b.h"
  11:../timer2.c   **** #include "44blib.h"
  12:../timer2.c   **** 
  13:../timer2.c   **** /*--- variables internas ---*/
  14:../timer2.c   **** /* Variable compartida con la rutina de interrupción que cuenta los periodos completos */
  15:../timer2.c   **** static volatile unsigned int timer2_numero_int = 0;
  16:../timer2.c   **** 
  17:../timer2.c   **** /* Declaración de función que es rutina de servicio de interrupción
  18:../timer2.c   ****  * https://gcc.gnu.org/onlinedocs/gcc/ARM-Function-Attributes.html */
  19:../timer2.c   **** void timer2_ISR(void) __attribute__((interrupt("IRQ")));
  20:../timer2.c   **** 
  21:../timer2.c   **** /*--- código de las funciones ---*/
  22:../timer2.c   **** 
  23:../timer2.c   **** /**
  24:../timer2.c   ****  * Rutina de servicio de interrupción del Timer2.
  25:../timer2.c   ****  * Se ejecuta cada vez que el timer2 completa un ciclo de cuenta.
  26:../timer2.c   ****  * Incrementa el contador de interrupciones.
  27:../timer2.c   ****  * 
  28:../timer2.c   ****  * NOTA: No registramos cada interrupción en la cola para no sobrecargarla,
  29:../timer2.c   ****  * ya que el timer2 genera muchas interrupciones por segundo (~488 Hz).
  30:../timer2.c   ****  * Solo registramos si es necesario para depuración específica.
  31:../timer2.c   ****  */
  32:../timer2.c   **** void timer2_ISR(void)
  33:../timer2.c   **** {
 1888              		.loc 1 33 0
 1889              		.cfi_startproc
 1890              		@ Interrupt Service Routine.
 1891              		@ args = 0, pretend = 0, frame = 0
 1892              		@ frame_needed = 1, uses_anonymous_args = 0
 1893 0000 04C02DE5 		str	ip, [sp, #-4]!
 1894 0004 0DC0A0E1 		mov	ip, sp
 1895              	.LCFI0:
 1896              		.cfi_def_cfa_register 12
 1897 0008 0CD82DE9 		stmfd	sp!, {r2, r3, fp, ip, lr, pc}
 1898 000c 04B04CE2 		sub	fp, ip, #4
 1899              		.cfi_offset 14, -8
 1900              		.cfi_offset 13, -12
 1901              		.cfi_offset 11, -16
 1902              		.cfi_offset 3, -20
 1903              		.cfi_offset 2, -24
 1904              	.LCFI1:
 1905              		.cfi_def_cfa 11, 4
  34:../timer2.c   **** 	/* Incrementar el contador de periodos completos */
  35:../timer2.c   **** 	timer2_numero_int++;
 1906              		.loc 1 35 0
 1907 0010 30309FE5 		ldr	r3, .L2
 1908 0014 003093E5 		ldr	r3, [r3, #0]
 1909 0018 012083E2 		add	r2, r3, #1
 1910 001c 24309FE5 		ldr	r3, .L2
 1911 0020 002083E5 		str	r2, [r3, #0]
  36:../timer2.c   **** 	
  37:../timer2.c   **** 	/* Borrar bit en I_ISPC para desactivar la solicitud de interrupción */
  38:../timer2.c   **** 	rI_ISPC |= BIT_TIMER2; // BIT_TIMER2 pone un uno en el bit 11 que corresponde al Timer2
 1912              		.loc 1 38 0
 1913 0024 20309FE5 		ldr	r3, .L2+4
 1914 0028 1C209FE5 		ldr	r2, .L2+4
 1915 002c 002092E5 		ldr	r2, [r2, #0]
 1916 0030 022B82E3 		orr	r2, r2, #2048
 1917 0034 002083E5 		str	r2, [r3, #0]
  39:../timer2.c   **** }
 1918              		.loc 1 39 0
 1919 0038 14D04BE2 		sub	sp, fp, #20
 1920 003c 0C689DE8 		ldmfd	sp, {r2, r3, fp, sp, lr}
 1921 0040 04C09DE4 		ldmfd	sp!, {ip}
 1922 0044 04F05EE2 		subs	pc, lr, #4
 1923              	.L3:
 1924              		.align	2
 1925              	.L2:
 1926 0048 00000000 		.word	timer2_numero_int
 1927 004c 2400E001 		.word	31457316
 1928              		.cfi_endproc
 1929              	.LFE0:
 1931              		.align	2
 1932              		.global	timer2_init
 1934              	timer2_init:
 1935              	.LFB1:
  40:../timer2.c   **** 
  41:../timer2.c   **** /**
  42:../timer2.c   ****  * Inicializa el timer2 para trabajar a la máxima precisión posible.
  43:../timer2.c   ****  * Configuración:
  44:../timer2.c   ****  * - Reloj de la placa: 64 MHz
  45:../timer2.c   ****  * - Preescalado: 1 (valor 0 en TCFG0 para timer2/3)
  46:../timer2.c   ****  * - Divisor: 1/2 (valor 0 en TCFG1 para timer2)
  47:../timer2.c   ****  * - Frecuencia final del timer: 64 MHz / (0+1) / 2 = 32 MHz
  48:../timer2.c   ****  * - Periodo del timer: 1/32 MHz = 0.03125 microsegundos
  49:../timer2.c   ****  * - Valor de cuenta máximo: 65535 (16 bits)
  50:../timer2.c   ****  * - Tiempo por ciclo completo: 65535 * 0.03125 = 2047.96875 microsegundos (~2.048 ms)
  51:../timer2.c   ****  */
  52:../timer2.c   **** void timer2_init(void)
  53:../timer2.c   **** {
 1936              		.loc 1 53 0
 1937              		.cfi_startproc
 1938              		@ Function supports interworking.
 1939              		@ args = 0, pretend = 0, frame = 0
 1940              		@ frame_needed = 1, uses_anonymous_args = 0
 1941 0050 0DC0A0E1 		mov	ip, sp
 1942              	.LCFI2:
 1943              		.cfi_def_cfa_register 12
 1944 0054 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1945 0058 04B04CE2 		sub	fp, ip, #4
 1946              		.cfi_offset 14, -8
 1947              		.cfi_offset 13, -12
 1948              		.cfi_offset 11, -16
 1949              	.LCFI3:
 1950              		.cfi_def_cfa 11, 4
  54:../timer2.c   **** 	/* Configuración del controlador de interrupciones */
  55:../timer2.c   **** 	rINTMOD = 0x0;              // Configura las líneas como de tipo IRQ
 1951              		.loc 1 55 0
 1952 005c EC309FE5 		ldr	r3, .L5
 1953 0060 0020A0E3 		mov	r2, #0
 1954 0064 002083E5 		str	r2, [r3, #0]
  56:../timer2.c   **** 	rINTCON = 0x1;              // Habilita int. vectorizadas y la línea IRQ (FIQ no)
 1955              		.loc 1 56 0
 1956 0068 1E36A0E3 		mov	r3, #31457280
 1957 006c 0120A0E3 		mov	r2, #1
 1958 0070 002083E5 		str	r2, [r3, #0]
  57:../timer2.c   **** 	rINTMSK &= ~(BIT_TIMER2);   // Habilita en vector de máscaras de interrupción el Timer2
 1959              		.loc 1 57 0
 1960 0074 D8309FE5 		ldr	r3, .L5+4
 1961 0078 D4209FE5 		ldr	r2, .L5+4
 1962 007c 002092E5 		ldr	r2, [r2, #0]
 1963 0080 022BC2E3 		bic	r2, r2, #2048
 1964 0084 002083E5 		str	r2, [r3, #0]
  58:../timer2.c   **** 	
  59:../timer2.c   **** 	/* Establece la rutina de servicio para TIMER2 */
  60:../timer2.c   **** 	pISR_TIMER2 = (unsigned) timer2_ISR;
 1965              		.loc 1 60 0
 1966 0088 C8309FE5 		ldr	r3, .L5+8
 1967 008c C8209FE5 		ldr	r2, .L5+12
 1968 0090 002083E5 		str	r2, [r3, #0]
  61:../timer2.c   **** 	
  62:../timer2.c   **** 	/* Configura el Timer2 para máxima precisión */
  63:../timer2.c   **** 	/* TCFG0: registro de preescalado
  64:../timer2.c   **** 	 * Timer2 y Timer3 comparten los bits [15:8]
  65:../timer2.c   **** 	 * Preescalado = 0 para máxima precisión (divide por 1) */
  66:../timer2.c   **** 	rTCFG0 &= ~(0xFF << 8);     // Limpia los bits [15:8]
 1969              		.loc 1 66 0
 1970 0094 C4309FE5 		ldr	r3, .L5+16
 1971 0098 C0209FE5 		ldr	r2, .L5+16
 1972 009c 002092E5 		ldr	r2, [r2, #0]
 1973 00a0 FF2CC2E3 		bic	r2, r2, #65280
 1974 00a4 002083E5 		str	r2, [r3, #0]
  67:../timer2.c   **** 	rTCFG0 |= (0 << 8);         // Establece preescalado = 0 (divide por 0+1 = 1)
 1975              		.loc 1 67 0
 1976 00a8 B0309FE5 		ldr	r3, .L5+16
 1977 00ac AC209FE5 		ldr	r2, .L5+16
 1978 00b0 002092E5 		ldr	r2, [r2, #0]
 1979 00b4 002083E5 		str	r2, [r3, #0]
  68:../timer2.c   **** 	
  69:../timer2.c   **** 	/* TCFG1: registro de selección de divisor
  70:../timer2.c   **** 	 * Timer2 usa los bits [11:8]
  71:../timer2.c   **** 	 * Valor 0000 = divisor 1/2 */
  72:../timer2.c   **** 	rTCFG1 &= ~(0xF << 8);      // Limpia los bits [11:8]
 1980              		.loc 1 72 0
 1981 00b8 A4309FE5 		ldr	r3, .L5+20
 1982 00bc A0209FE5 		ldr	r2, .L5+20
 1983 00c0 002092E5 		ldr	r2, [r2, #0]
 1984 00c4 0F2CC2E3 		bic	r2, r2, #3840
 1985 00c8 002083E5 		str	r2, [r3, #0]
  73:../timer2.c   **** 	rTCFG1 |= (0x0 << 8);       // Establece divisor = 1/2
 1986              		.loc 1 73 0
 1987 00cc 90309FE5 		ldr	r3, .L5+20
 1988 00d0 8C209FE5 		ldr	r2, .L5+20
 1989 00d4 002092E5 		ldr	r2, [r2, #0]
 1990 00d8 002083E5 		str	r2, [r3, #0]
  74:../timer2.c   **** 	
  75:../timer2.c   **** 	/* TCNTB2: valor inicial de cuenta (cuenta descendente) 
  76:../timer2.c   **** 	 * Usamos el valor máximo de 16 bits para maximizar el rango */
  77:../timer2.c   **** 	rTCNTB2 = 65535;
 1991              		.loc 1 77 0
 1992 00dc 84309FE5 		ldr	r3, .L5+24
 1993 00e0 84209FE5 		ldr	r2, .L5+28
 1994 00e4 002083E5 		str	r2, [r3, #0]
  78:../timer2.c   **** 	
  79:../timer2.c   **** 	/* TCMPB2: valor de comparación (no se usa para medición de tiempo) */
  80:../timer2.c   **** 	rTCMPB2 = 0;
 1995              		.loc 1 80 0
 1996 00e8 80309FE5 		ldr	r3, .L5+32
 1997 00ec 0020A0E3 		mov	r2, #0
 1998 00f0 002083E5 		str	r2, [r3, #0]
  81:../timer2.c   **** 	
  82:../timer2.c   **** 	/* TCON: registro de control del timer
  83:../timer2.c   **** 	 * Timer2 usa los bits [15:12]
  84:../timer2.c   **** 	 * Bit 15: Timer2 start/stop (0=stop, 1=start)
  85:../timer2.c   **** 	 * Bit 14: Timer2 manual update (1=update TCNTB2 y TCMPB2)
  86:../timer2.c   **** 	 * Bit 13: Timer2 output inverter on/off
  87:../timer2.c   **** 	 * Bit 12: Timer2 auto reload on/off (1=auto-reload) */
  88:../timer2.c   **** 	
  89:../timer2.c   **** 	/* Primero establecer manual update para cargar los valores */
  90:../timer2.c   **** 	rTCON &= ~(0xF << 12);      // Limpia los bits del Timer2
 1999              		.loc 1 90 0
 2000 00f4 78309FE5 		ldr	r3, .L5+36
 2001 00f8 74209FE5 		ldr	r2, .L5+36
 2002 00fc 002092E5 		ldr	r2, [r2, #0]
 2003 0100 0F2AC2E3 		bic	r2, r2, #61440
 2004 0104 002083E5 		str	r2, [r3, #0]
  91:../timer2.c   **** 	rTCON |= (1 << 13);         // Establece manual update
 2005              		.loc 1 91 0
 2006 0108 64309FE5 		ldr	r3, .L5+36
 2007 010c 60209FE5 		ldr	r2, .L5+36
 2008 0110 002092E5 		ldr	r2, [r2, #0]
 2009 0114 022A82E3 		orr	r2, r2, #8192
 2010 0118 002083E5 		str	r2, [r3, #0]
  92:../timer2.c   **** 	
  93:../timer2.c   **** 	/* Luego iniciar el timer con auto-reload (sin manual update) */
  94:../timer2.c   **** 	rTCON &= ~(0xF << 12);      // Limpia los bits del Timer2
 2011              		.loc 1 94 0
 2012 011c 50309FE5 		ldr	r3, .L5+36
 2013 0120 4C209FE5 		ldr	r2, .L5+36
 2014 0124 002092E5 		ldr	r2, [r2, #0]
 2015 0128 0F2AC2E3 		bic	r2, r2, #61440
 2016 012c 002083E5 		str	r2, [r3, #0]
  95:../timer2.c   **** 	rTCON |= (1 << 15) | (1 << 12);  // Start + auto-reload
 2017              		.loc 1 95 0
 2018 0130 3C309FE5 		ldr	r3, .L5+36
 2019 0134 38209FE5 		ldr	r2, .L5+36
 2020 0138 002092E5 		ldr	r2, [r2, #0]
 2021 013c 092A82E3 		orr	r2, r2, #36864
 2022 0140 002083E5 		str	r2, [r3, #0]
  96:../timer2.c   **** }
 2023              		.loc 1 96 0
 2024 0144 0CD04BE2 		sub	sp, fp, #12
 2025 0148 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2026 014c 1EFF2FE1 		bx	lr
 2027              	.L6:
 2028              		.align	2
 2029              	.L5:
 2030 0150 0800E001 		.word	31457288
 2031 0154 0C00E001 		.word	31457292
 2032 0158 4CFF7F0C 		.word	209715020
 2033 015c 00000000 		.word	timer2_ISR
 2034 0160 0000D501 		.word	30736384
 2035 0164 0400D501 		.word	30736388
 2036 0168 2400D501 		.word	30736420
 2037 016c FFFF0000 		.word	65535
 2038 0170 2800D501 		.word	30736424
 2039 0174 0800D501 		.word	30736392
 2040              		.cfi_endproc
 2041              	.LFE1:
 2043              		.align	2
 2044              		.global	timer2_start
 2046              	timer2_start:
 2047              	.LFB2:
  97:../timer2.c   **** 
  98:../timer2.c   **** /**
  99:../timer2.c   ****  * Reinicia la cuenta de tiempo y comienza a medir.
 100:../timer2.c   ****  * Resetea tanto el contador de interrupciones como el valor del timer.
 101:../timer2.c   ****  */
 102:../timer2.c   **** void timer2_start(void)
 103:../timer2.c   **** {
 2048              		.loc 1 103 0
 2049              		.cfi_startproc
 2050              		@ Function supports interworking.
 2051              		@ args = 0, pretend = 0, frame = 0
 2052              		@ frame_needed = 1, uses_anonymous_args = 0
 2053 0178 0DC0A0E1 		mov	ip, sp
 2054              	.LCFI4:
 2055              		.cfi_def_cfa_register 12
 2056 017c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2057 0180 04B04CE2 		sub	fp, ip, #4
 2058              		.cfi_offset 14, -8
 2059              		.cfi_offset 13, -12
 2060              		.cfi_offset 11, -16
 2061              	.LCFI5:
 2062              		.cfi_def_cfa 11, 4
 104:../timer2.c   **** 	/* Reiniciar el contador de interrupciones */
 105:../timer2.c   **** 	timer2_numero_int = 0;
 2063              		.loc 1 105 0
 2064 0184 6C309FE5 		ldr	r3, .L8
 2065 0188 0020A0E3 		mov	r2, #0
 2066 018c 002083E5 		str	r2, [r3, #0]
 106:../timer2.c   **** 	
 107:../timer2.c   **** 	/* Detener el timer */
 108:../timer2.c   **** 	rTCON &= ~(1 << 15);        // Clear bit 15 (stop timer2)
 2067              		.loc 1 108 0
 2068 0190 64309FE5 		ldr	r3, .L8+4
 2069 0194 60209FE5 		ldr	r2, .L8+4
 2070 0198 002092E5 		ldr	r2, [r2, #0]
 2071 019c 0229C2E3 		bic	r2, r2, #32768
 2072 01a0 002083E5 		str	r2, [r3, #0]
 109:../timer2.c   **** 	
 110:../timer2.c   **** 	/* Recargar el valor inicial del contador */
 111:../timer2.c   **** 	rTCNTB2 = 65535;
 2073              		.loc 1 111 0
 2074 01a4 54309FE5 		ldr	r3, .L8+8
 2075 01a8 54209FE5 		ldr	r2, .L8+12
 2076 01ac 002083E5 		str	r2, [r3, #0]
 112:../timer2.c   **** 	
 113:../timer2.c   **** 	/* Establecer manual update para recargar el valor */
 114:../timer2.c   **** 	rTCON |= (1 << 13);         // Set manual update
 2077              		.loc 1 114 0
 2078 01b0 44309FE5 		ldr	r3, .L8+4
 2079 01b4 40209FE5 		ldr	r2, .L8+4
 2080 01b8 002092E5 		ldr	r2, [r2, #0]
 2081 01bc 022A82E3 		orr	r2, r2, #8192
 2082 01c0 002083E5 		str	r2, [r3, #0]
 115:../timer2.c   **** 	
 116:../timer2.c   **** 	/* Iniciar el timer con auto-reload */
 117:../timer2.c   **** 	rTCON &= ~(0xF << 12);      // Limpia los bits del Timer2
 2083              		.loc 1 117 0
 2084 01c4 30309FE5 		ldr	r3, .L8+4
 2085 01c8 2C209FE5 		ldr	r2, .L8+4
 2086 01cc 002092E5 		ldr	r2, [r2, #0]
 2087 01d0 0F2AC2E3 		bic	r2, r2, #61440
 2088 01d4 002083E5 		str	r2, [r3, #0]
 118:../timer2.c   **** 	rTCON |= (1 << 15) | (1 << 12);  // Start + auto-reload
 2089              		.loc 1 118 0
 2090 01d8 1C309FE5 		ldr	r3, .L8+4
 2091 01dc 18209FE5 		ldr	r2, .L8+4
 2092 01e0 002092E5 		ldr	r2, [r2, #0]
 2093 01e4 092A82E3 		orr	r2, r2, #36864
 2094 01e8 002083E5 		str	r2, [r3, #0]
 119:../timer2.c   **** }
 2095              		.loc 1 119 0
 2096 01ec 0CD04BE2 		sub	sp, fp, #12
 2097 01f0 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2098 01f4 1EFF2FE1 		bx	lr
 2099              	.L9:
 2100              		.align	2
 2101              	.L8:
 2102 01f8 00000000 		.word	timer2_numero_int
 2103 01fc 0800D501 		.word	30736392
 2104 0200 2400D501 		.word	30736420
 2105 0204 FFFF0000 		.word	65535
 2106              		.cfi_endproc
 2107              	.LFE2:
 2109              		.align	2
 2110              		.global	timer2_count
 2112              	timer2_count:
 2113              	.LFB3:
 120:../timer2.c   **** 
 121:../timer2.c   **** /**
 122:../timer2.c   ****  * Lee la cuenta actual del temporizador y calcula el tiempo transcurrido.
 123:../timer2.c   ****  * 
 124:../timer2.c   ****  * Retorna el tiempo en microsegundos desde la última llamada a timer2_start().
 125:../timer2.c   ****  * 
 126:../timer2.c   ****  * Cálculo:
 127:../timer2.c   ****  * - Frecuencia del timer: 32 MHz (64 MHz / 1 / 2)
 128:../timer2.c   ****  * - Cada tick del timer: 0.03125 microsegundos (1/32 MHz)
 129:../timer2.c   ****  * - Ticks transcurridos = (65535 - TCNTO2) + (65536 * timer2_numero_int)
 130:../timer2.c   ****  * - Tiempo (µs) = ticks * 0.03125 = ticks / 32
 131:../timer2.c   ****  */
 132:../timer2.c   **** unsigned int timer2_count(void)
 133:../timer2.c   **** {
 2114              		.loc 1 133 0
 2115              		.cfi_startproc
 2116              		@ Function supports interworking.
 2117              		@ args = 0, pretend = 0, frame = 24
 2118              		@ frame_needed = 1, uses_anonymous_args = 0
 2119 0208 0DC0A0E1 		mov	ip, sp
 2120              	.LCFI6:
 2121              		.cfi_def_cfa_register 12
 2122 020c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2123 0210 04B04CE2 		sub	fp, ip, #4
 2124              		.cfi_offset 14, -8
 2125              		.cfi_offset 13, -12
 2126              		.cfi_offset 11, -16
 2127              	.LCFI7:
 2128              		.cfi_def_cfa 11, 4
 2129 0214 18D04DE2 		sub	sp, sp, #24
 134:../timer2.c   **** 	unsigned int interrupciones;
 135:../timer2.c   **** 	unsigned int contador_actual;
 136:../timer2.c   **** 	unsigned int ticks_totales;
 137:../timer2.c   **** 	unsigned int tiempo_us;
 138:../timer2.c   **** 	
 139:../timer2.c   **** 	/* Leer el número de interrupciones de forma atómica */
 140:../timer2.c   **** 	interrupciones = timer2_numero_int;
 2130              		.loc 1 140 0
 2131 0218 54309FE5 		ldr	r3, .L11
 2132 021c 003093E5 		ldr	r3, [r3, #0]
 2133 0220 10300BE5 		str	r3, [fp, #-16]
 141:../timer2.c   **** 	
 142:../timer2.c   **** 	/* Leer el valor actual del contador (cuenta descendente desde 65535) */
 143:../timer2.c   **** 	contador_actual = rTCNTO2;
 2134              		.loc 1 143 0
 2135 0224 4C309FE5 		ldr	r3, .L11+4
 2136 0228 003093E5 		ldr	r3, [r3, #0]
 2137 022c 14300BE5 		str	r3, [fp, #-20]
 144:../timer2.c   **** 	
 145:../timer2.c   **** 	/* Calcular los ticks transcurridos en el periodo actual */
 146:../timer2.c   **** 	/* Como cuenta descendente: ticks = valor_inicial - valor_actual */
 147:../timer2.c   **** 	unsigned int ticks_periodo_actual = 65535 - contador_actual;
 2138              		.loc 1 147 0
 2139 0230 14301BE5 		ldr	r3, [fp, #-20]
 2140 0234 FF3C63E2 		rsb	r3, r3, #65280
 2141 0238 FF3083E2 		add	r3, r3, #255
 2142 023c 18300BE5 		str	r3, [fp, #-24]
 148:../timer2.c   **** 	
 149:../timer2.c   **** 	/* Calcular el total de ticks:
 150:../timer2.c   **** 	 * ticks totales = ticks de periodos completos + ticks del periodo actual */
 151:../timer2.c   **** 	ticks_totales = (interrupciones * 65536) + ticks_periodo_actual;
 2143              		.loc 1 151 0
 2144 0240 10301BE5 		ldr	r3, [fp, #-16]
 2145 0244 0328A0E1 		mov	r2, r3, asl #16
 2146 0248 18301BE5 		ldr	r3, [fp, #-24]
 2147 024c 033082E0 		add	r3, r2, r3
 2148 0250 1C300BE5 		str	r3, [fp, #-28]
 152:../timer2.c   **** 	
 153:../timer2.c   **** 	/* Convertir ticks a microsegundos:
 154:../timer2.c   **** 	 * Cada tick = 1/(32 MHz) = 0.03125 µs
 155:../timer2.c   **** 	 * Tiempo (µs) = ticks / 32
 156:../timer2.c   **** 	 * Para evitar usar división en punto flotante: ticks * 1000000 / 32000000 = ticks / 32 */
 157:../timer2.c   **** 	tiempo_us = ticks_totales / 32;
 2149              		.loc 1 157 0
 2150 0254 1C301BE5 		ldr	r3, [fp, #-28]
 2151 0258 A332A0E1 		mov	r3, r3, lsr #5
 2152 025c 20300BE5 		str	r3, [fp, #-32]
 158:../timer2.c   **** 	
 159:../timer2.c   **** 	return tiempo_us;
 2153              		.loc 1 159 0
 2154 0260 20301BE5 		ldr	r3, [fp, #-32]
 160:../timer2.c   **** }
 2155              		.loc 1 160 0
 2156 0264 0300A0E1 		mov	r0, r3
 2157 0268 0CD04BE2 		sub	sp, fp, #12
 2158 026c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2159 0270 1EFF2FE1 		bx	lr
 2160              	.L12:
 2161              		.align	2
 2162              	.L11:
 2163 0274 00000000 		.word	timer2_numero_int
 2164 0278 2C00D501 		.word	30736428
 2165              		.cfi_endproc
 2166              	.LFE3:
 2168              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 timer2.c
C:\Users\jaime\AppData\Local\Temp\ccPfcC6O.s:1879   .bss:00000000 $d
C:\Users\jaime\AppData\Local\Temp\ccPfcC6O.s:1880   .bss:00000000 timer2_numero_int
C:\Users\jaime\AppData\Local\Temp\ccPfcC6O.s:1883   .text:00000000 $a
C:\Users\jaime\AppData\Local\Temp\ccPfcC6O.s:1886   .text:00000000 timer2_ISR
C:\Users\jaime\AppData\Local\Temp\ccPfcC6O.s:1926   .text:00000048 $d
C:\Users\jaime\AppData\Local\Temp\ccPfcC6O.s:1931   .text:00000050 $a
C:\Users\jaime\AppData\Local\Temp\ccPfcC6O.s:1934   .text:00000050 timer2_init
C:\Users\jaime\AppData\Local\Temp\ccPfcC6O.s:2030   .text:00000150 $d
C:\Users\jaime\AppData\Local\Temp\ccPfcC6O.s:2043   .text:00000178 $a
C:\Users\jaime\AppData\Local\Temp\ccPfcC6O.s:2046   .text:00000178 timer2_start
C:\Users\jaime\AppData\Local\Temp\ccPfcC6O.s:2102   .text:000001f8 $d
C:\Users\jaime\AppData\Local\Temp\ccPfcC6O.s:2109   .text:00000208 $a
C:\Users\jaime\AppData\Local\Temp\ccPfcC6O.s:2112   .text:00000208 timer2_count
C:\Users\jaime\AppData\Local\Temp\ccPfcC6O.s:2163   .text:00000274 $d
                     .debug_frame:00000010 $d

NO UNDEFINED SYMBOLS
