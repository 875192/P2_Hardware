/*
* Codigo de otro proyecto anterior (utilizaban una pila, en el nuestro utilizamos una cola).
* Este archivo sirve como guia para realizar este proyecto nuevo. Para eliminacion de rebotes, otro timer.
*/

####################################################################################################################
####################################################################################################################


/* COLA.C */
/*********************************************************************************************
* Fichero:		cola.c
* Autor:       David Colás y Álvaro Pérez
* Descrip:		Funciones de control de la pila de depuracion
* Version:
*********************************************************************************************/

/*--- Ficheros de cabecera ---*/
#include "44b.h"
#include "44blib.h"
#include <stdint.h>
#include "cola.h"
#include "eventos.h"

/*--- Variables globales del módulo ---*/

/*--- Código de las funciones públicas ---*/

/**
 * @brief Inicializa la pila de depuración
 * @param P Puntero a la pila de depuración
 */
 void inicializar_pila( PilaInt* P )
 {
	int i;
    P->num = 0;
    for(i = 0; i < DEBUG_STACK_SIZE; i++){
    	P->ID[i] = 0;
    	P->cuando[i] = 0;
    }
 }

/**
 * @brief Añade un evento a la pila de depuración
 * @param P Puntero a la pila de depuración
 * @param ID_evento Identificador del evento
 * @param cuando Tiempo en el que se ha producido el evento
 */
 void push_debug(PilaInt* P, uint8_t ID_evento, uint32_t cuando)
 {
    P->ID[ P->num] = ID_evento;
    P->cuando[ P->num] = cuando;
    P->num++;
 }


####################################################################################################################
####################################################################################################################


/* COLA.H */
/*********************************************************************************************
* Fichero:		cola.h
* Autor:       David Colás y Álvaro Pérez
* Descrip:		Cabeceras de funciones de control de la pila de depuracion
* Version:
*********************************************************************************************/

#ifndef _COLA_H_
#define _COLA_H_
#include <stdint.h>

#define DEBUG_STACK_SIZE 150 * 2 // Tamaño de la pila de depuración
#define DEBUG_STACK_ADDRESS (0xc7ff000 - sizeof(DEBUG_STACK_SIZE)) // Direccion de la pila de depuración

/*--- Variables visibles del modulo cola.c/cola.h ---*/
 typedef struct {
    int num;  //Número de elementos en la pila
    uint8_t ID[DEBUG_STACK_SIZE]; //Array que almacena el ID de los eventos
    uint32_t cuando[DEBUG_STACK_SIZE]; //Array que almacena el tiempo de los eventos
 } PilaInt;

PilaInt* pila_global; 

/*--- Declaracion de funciones visibles del modulo cola.c/cola.h ---*/
 void inicializar_pila( PilaInt* P );
 void push_debug(PilaInt* P, uint8_t ID_evento, uint32_t cuando);

#endif /* _COLA_H_ */


####################################################################################################################
####################################################################################################################


/* EVENTOS.H */
/*********************************************************************************************
* File: 	    eventos.h
* Author:	    David Colás y Álvaro Pérez
* Desc: 	    Posibles eventos para la pila de depuracion
* History:
*********************************************************************************************/

#ifndef __EVENTOS_H_
#define __EVENTOS_H_

#define EVENTO_INT_1 1
#define EVENTO_INT_2 2

typedef enum {
    ESPERANDO_PULSACION,
    REBOTE_PRESION,
    MONITORIZANDO,
    REBOTE_DEPRESION
} EstadoPulsador;

typedef enum {
    ESPERANDO_INICIO,
    INICIO,
    INTRODUCIR_FILA,
    INTRODUCIR_COLUMNA,
    VERIFICAR_VALOR,
    BORRAR_VALOR,
    INTRODUCIR_VALOR,
} EstadoSudoku;

#endif // __EVENTOS_H_

####################################################################################################################
####################################################################################################################

/* BUTTON.C */

/*********************************************************************************************
* Fichero:		button.c
* Autor:		David Colás y Álvaro Pérez
* Descrip:		Funciones de manejo de los pulsadores (EINT6-7)
* Version:
*********************************************************************************************/

/*--- Ficheros de cabecera ---*/
#include "button.h"
#include "8led.h"
#include "44blib.h"
#include "44b.h"
#include "def.h"
#include "eventos.h"
#include "cola.h"
#include "timer.h"

/*--- Variables globales del modulo ---*/
volatile int boton_pulsado = 0;

/* Declaracion de funcion que es rutina de servicio de interrupcion
 * https://gcc.gnu.org/onlinedocs/gcc/ARM-Function-Attributes.html */
void Eint4567_ISR(void) __attribute__((interrupt("IRQ")));

/*--- Codigo de funciones de interrupcion---*/

/**
 * @brief Rutina de servicio de interrupción de los pulsadores
 * Introduce en la pila de depuración el evento correspondiente y
 * activa el flag de timer1 para gestionar los rebotes
 */
void Eint4567_ISR(void)
{	
    /* Deshabilitar las interrupciones de los botones */
    rINTMSK |= BIT_EINT4567;

	//Identificar la interrupcion (hay dos pulsadores) y meter en la pila
	switch (rEXTINTPND)
	{
		case 4:
			push_debug(pila_global, EVENTO_INT_1, timer1_leer());
			break;
		case 8:
			push_debug(pila_global, EVENTO_INT_2, timer1_leer());
			break;
		default:
			break;
	}
	
    /* Registrar el tiempo de inicio */
    tiempo_inicio = timer1_leer();

    /* Cambiar de estado */
    estado_pulsador = REBOTE_PRESION;
	timer1_flag = 1;
     
	/* Finalizar ISR */
	rI_ISPC   |= BIT_EINT4567;		// borra el bit pendiente en INTPND
}

/*--- Código de funciones ---*/

/**
 * @brief Inicializa los pulsadores EINT4-7
 */
void Eint4567_inicializar(void)
{
	/* Configuracion del controlador de interrupciones. Estos registros estan definidos en 44b.h */
	rI_ISPC    |= BIT_EINT4567;		// Borrar bit en I_ISPC para desactivar la solicitud de interrupción
	rEXTINTPND = 0xf;       	// Borra EXTINTPND escribiendo 1s en el propio registro
	//rINTMOD    = 0x0;		// Configura las lineas como de tipo IRQ
	//rINTCON    = 0x1;		// Habilita int. vectorizadas y la linea IRQ (FIQ no)
	rINTMSK    &= ~(BIT_EINT4567);  // Habilitamos interrupcion linea eint4567 en vector de mascaras

	/* Establece la rutina de servicio para Eint4567 */
	pISR_EINT4567 = (int) Eint4567_ISR;

	/* Configuracion del puerto G */
	rPCONG |= 0xFF00;        		// Establece la funcion de los pines (EINT4-7)
	rPUPG   = 0x0;                  // Habilita el "pull up" del puerto
	rEXTINT = (rEXTINT & ~(0x7FFF << 16)) | (0x2AAA << 16);  // Configura las lineas de int. como de flanco de bajada

	/* Por precauacion, se vuelven a borrar los bits de INTPND y EXTINTPND */
	rEXTINTPND = 0xf;				// Borra los bits en EXTINTPND
	rI_ISPC   |= BIT_EINT4567;		// Borra el bit pendiente en INTPND
}


####################################################################################################################
####################################################################################################################


/*********************************************************************************************
* Fichero:	    button.h
* Autor:        David Colás y Álvaro Pérez
* Descrip:	    Funciones de manejo de los pulsadores (EINT6-7)
* Version:
*********************************************************************************************/

#ifndef _BUTTON_H_
#define _BUTTON_H_
#include "eventos.h"

/*--- Declaración de funciones visibles del módulo button.c/button.h ---*/
void Eint4567_inicializar(void);
extern volatile int timer1_flag;
extern volatile EstadoPulsador estado_pulsador;

#endif /* _BUTTON_H_ */


####################################################################################################################
####################################################################################################################


/*********************************************************************************************
* Fichero:		timer.c
* Autor:		David Colás y Álvaro Pérez
* Descrip:		Funciones de control de los timer del s3c44b0x
* Version:		
*********************************************************************************************/

/*--- Ficheros de cabecera ---*/
#include "timer.h"
#include "44b.h"
#include "44blib.h"
#include "led.h"
#include "eventos.h"
#include "button.h"
#include "8led.h"

/*--- Variables globales ---*/
volatile int switch_leds = 0;
volatile int timer1_num_int = 0;
volatile int timer2_num_int = 0;
volatile int led2_encendido = 0;
volatile unsigned int tiempo_actual = 0;
volatile unsigned int tiempo_transcurrido = 0;

volatile EstadoPulsador estado_pulsador = ESPERANDO_PULSACION;
volatile EstadoSudoku estado_sudoku = ESPERANDO_INICIO;

float trp = 25000;  // Retardo inicial de presión (ms)
float trd = 25000;  // Retardo final de depresión (ms)
float intervalo_monitorizacion = 50000; // Intervalo de monitorización (ms)
volatile int timer1_flag = 0; // Definición de la variable global

volatile int fila = 0;
volatile int columna = 0;
volatile int valor = 0;

/* int_count la utilizamos para sacar un numero por el 8led.
  Cuando se pulsa un boton sumamos y con el otro restamos. A veces hay rebotes! */
volatile int int_count = 0;

/* Declaración de función que es rutina de servicio de interrupcion
 * https://gcc.gnu.org/onlinedocs/gcc/ARM-Function-Attributes.html */
void timer0_ISR(void) __attribute__((interrupt("IRQ")));
void timer1_ISR(void) __attribute__((interrupt("IRQ")));
void timer2_ISR(void) __attribute__((interrupt("IRQ")));

int leer_estado_boton(void);

/*--- Código de las funciones de interrupción---*/

/**
 * @brief Rutina de servicio de interrupción del temporizador 0
 */
void timer0_ISR(void)
{
	switch_leds = 1;

	/* Borrar bit en I_ISPC para desactivar la solicitud de interrupción*/
	rI_ISPC |= BIT_TIMER0; // BIT_TIMER0 esta definido en 44b.h y pone un uno en el bit 13 que corresponde al Timer0
}

/**
 * @brief Rutina de servicio de interrupción del temporizador 1
 * Elimina los rebotes de los pulsadores y gestiona la entrada de datos
 */
void timer1_ISR(void)
{
    timer1_num_int++; // Incrementar el contador de interrupciones
    
	//Este fleg se activa en la rutina de servicio de interrupción de los pulsadores
	if (timer1_flag == 1){
		tiempo_actual = timer1_leer();
    	tiempo_transcurrido = tiempo_actual - tiempo_inicio;

		switch (estado_pulsador)
		{
			case REBOTE_PRESION:
				if (tiempo_transcurrido >= trp)
				{
					/* Pasado el tiempo de rebote de presión */
					tiempo_inicio = tiempo_actual; // Actulizar el tiempo
					estado_pulsador = MONITORIZANDO;
				}
				break;

			case MONITORIZANDO:
				if (tiempo_transcurrido >= intervalo_monitorizacion)
       			 {
          		 	 /* Actualizar el tiempo de monitoreo */
            		tiempo_inicio = tiempo_actual;

            		if (leer_estado_boton() == 1)
            		{
               	 		/* Si el botón ha sido soltado */
                		estado_pulsador = REBOTE_DEPRESION;
            		}
    			}
        		break;

			case REBOTE_DEPRESION:
				if (tiempo_transcurrido >= trd)
				{
					/* Identificar la interrupcion (hay dos pulsadores)*/
					int which_int = rEXTINTPND;
					switch (which_int)
					{
						case 4:
							int_count++; // Incrementamos el contador
							break;
						case 8:
						// 	int_count--; // Decrementamos el contador
							break;
						default:
							break;
					}
					
					//Una vez eliminados los rebotes, gestionamos la entrada de datos
					switch (estado_sudoku)
					{
					case ESPERANDO_INICIO:
						if ((which_int == 4) || (which_int == 8))  //Cualquier boton
						{
							estado_sudoku = INICIO;
							D8Led_symbol(15);
							int_count = 0;
						}
						break;

					case INTRODUCIR_FILA:
						if (int_count == 10) //Reiniciar contador
						{
							int_count = 1;
						}

						if(which_int == 8) //Boton derecho
						{
							fila = int_count;
							int_count = 0;
							estado_sudoku = INTRODUCIR_COLUMNA;
							D8Led_symbol(12);
						} else
						{
							D8Led_symbol(int_count);
						}
						break;	
					
					case INTRODUCIR_COLUMNA:
						if (int_count == 10) //Reiniciar contador
						{
							int_count = 1;
						}

						if(which_int == 8) //Boton derecho
						{
							columna = int_count;
							int_count = 0;
							estado_sudoku = VERIFICAR_VALOR;
							D8Led_symbol(0);
						} else
						{
							D8Led_symbol(int_count);
						}
						break;
					
					case VERIFICAR_VALOR:
						if (int_count == 10) //Reiniciar contador
						{
							int_count = 0;
						}

						if (int_count == 0 && which_int == 8) //Si metes un 0
						{
							int_count = 0;
							estado_sudoku = BORRAR_VALOR;

						} else if (which_int == 8) //Si metes un valor distinto de 0
						{
							valor = int_count;
							int_count = 0;
							estado_sudoku = INTRODUCIR_VALOR;
						} else
						{
							D8Led_symbol(int_count);
						}
						break;
					
					default:
						break;

					}
				/* Habilitar las interrupciones de los botones */
				rEXTINTPND = 0xf;
				rINTMSK &= ~(BIT_EINT4567);
	
				/* Volver al estado inicial */
				estado_pulsador = ESPERANDO_PULSACION;
				timer1_flag = 0; 
				rI_ISPC   |= BIT_EINT4567;        // Borra el bit pendiente en INTPND
			}
				break;

			default:
				break;
		}
	}
	rI_ISPC |= BIT_TIMER1; // Borrar bit en I_ISPC para desactivar la solicitud de interrupción
}

/**
 * @brief Leer el estado de los botones
 * @return 0 si algún botón está pulsado, 1 si no hay botones pulsados
 */
int leer_estado_boton(void)
{
    // Invertir los bits para que los botones pulsados sean '1'
    unsigned int botones = (~rPDATG) & BITS_BOTONES;

    // Comprobar si algún botón está pulsado
    if (botones)
        return 0; // Al menos un botón está pulsado
    else
        return 1; // Ningún botón está pulsado
}

/**
 * @brief Rutina de servicio de interrupción del temporizador 2
 * Enciende y apaga el led2 cada 2 veces por segundo
 */
void timer2_ISR(void)
{
    timer2_num_int++; // Incrementar el contador de interrupciones

	if(timer2_num_int % 20 == 0){
		if (led2_encendido)
		{
			led2_encendido = 0;
			led2_off();
		}else{
			led2_encendido = 1;
			led2_on();
		}
	}			
    rI_ISPC |= BIT_TIMER2; // Borrar bit en I_ISPC para desactivar la solicitud de interrupción
}

/*---- Código de las funciones ----*/

/**
 * @brief Inicializa el temporizador 0
 */
void timer0_init(void)
{
	/* Configuración controlador de interrupciones */
	rINTMOD = 0x0; // Configura las lineas como de tipo IRQ
	rINTCON = 0x1; // Habilita int. vectorizadas y la linea IRQ (FIQ no)
	rINTMSK &= ~(BIT_TIMER0); // Habilitamos en vector de máscaras de interrupcion el Timer0 (bits 26 y 13, BIT_GLOBAL y BIT_TIMER0 están definidos en 44b.h)

	/* Establece la rutina de servicio para TIMER0 */
	pISR_TIMER0 = (unsigned) timer0_ISR;

	/* Configura el Timer0 */
	rTCFG0 = (rTCFG0 & ~0xFF) | 255; // Ajusta el preescalado (bits 7-0)
	rTCFG1 = (rTCFG1 & ~(0xF)) | (0x0); // Selecciona la entrada del mux que proporciona el reloj. La 00 corresponde a un divisor de 1/2.
	rTCNTB0 = 65535;// Valor inicial de cuenta (la cuenta es descendente)
	rTCMPB0 = 12800;// Valor de comparación
	/* Establecer update=manual (bit 1) + inverter=on (�? ser� inverter off un cero en el bit 2 pone el inverter en off)*/
	rTCON |= (1 << 9);
	/* Iniciar timer (bit 0) con auto-reload (bit 3) + manual update = off*/
	rTCON = ((rTCON & ~(0xF)) | (0x9)); // Poner a 1001 los bits del 11 al 8
}

/**
 * @brief Inicializa los temporizadores 1 y 2
 * El temporizador 1 se configura para la máxima precisón
 * y el 2 para lanzar 80 interrupciones por segundo
 */
void timer1_2_inicializar(void)
{
	/* Configuracion controlador de interrupciones */
	rINTMOD = 0x0; // Configura las lineas como de tipo IRQ
	rINTCON = 0x1; // Habilita int. vectorizadas y la linea IRQ (FIQ no)
	rINTMSK &= ~(BIT_TIMER1); // Habilitamos en vector de mascaras de interrupcion el Timer1

	/* Establece la rutina de servicio para TIMER1 */
	pISR_TIMER1 = (unsigned) timer1_ISR;

	/* Configura el Timer1 */
	rTCFG0 = (rTCFG0 & ~0xFF) | 0; // Ajusta el preescalado (bits 7-0)
	rTCFG1 = (rTCFG1 & ~(0xF << 4)) | (0x0 << 4); // Selecciona la entrada del mux que proporciona el reloj. La 01xx corresponde a un divisor de 1/2.
	rTCNTB1 = 65535;// Valor inicial de cuenta (la cuenta es descendente)
	rTCMPB1 = 0;// Valor de comparacion
	/* Establecer update=manual (bit 9) + inverter=off */
	rTCON |= (1 << 9);
	/* Iniciar timer (bit 8) con auto-reload (bit 11) + manual update = off*/
	rTCON = (rTCON & ~(0xF << 8)) | (0x8 << 8); // Poner 1000 en los bits del 8 al 11

	rINTMSK &= ~(BIT_TIMER2); // Habilitamos en vector de mascaras de interrupcion el Timer2

	/* Establece la rutina de servicio para TIMER2 */
	pISR_TIMER2 = (unsigned) timer2_ISR;

	/* Configura el Timer2 */
	rTCFG0 = (rTCFG0 & ~(0xFF << 8)) | (0x6 << 8); // Ajusta el preescalado a 6(bits 15-8)
	rTCFG1 = (rTCFG1 & ~(0xF << 8)) | (0x0 << 8); // Selecciona la entrada del mux que proporciona el reloj. La 01xx corresponde a un divisor de 1/2.
	rTCNTB2 = 57143;// Valor inicial de cuenta (la cuenta es descendente)
	rTCMPB2 = 0;// Valor de comparacion
	/* Establecer update=manual (bit 13) + inverter=off */
	rTCON |= (1 << 13);
	/* Iniciar timer (bit 12) con auto-reload (bit 15) + manual update = off*/
	rTCON = (rTCON & ~(0xF << 12)) | (0x9 << 12); // Poner 1001 en los bits del 15 al 12
}

/**
 * @brief Inicializa el temporizador 1
 */
void timer1_empezar(void)
{   
	timer1_num_int = 0; // Reiniciar el contador de interrupciones
	rTCNTO1 = rTCNTB1; // Reiniciar el contador del timer
	/* Establecer update=manual (bit 9) + inverter=off */
	//rTCON |= (1 << 9);
	/* Iniciar timer (bit 8) con auto-reload (bit 11) + manual update = off*/
	rTCON = (rTCON & ~(0xF << 8)) | (0x9 << 8); // Poner a 1001 los bits del 11 al 8	
}

/**
 * @brief Leer el valor del temporizador 1
 * @return Tiempo transcurrido en microsegundos
 */
unsigned int timer1_leer(void)
{
	int Ftimer = ((MCLK / ((0 + 1) * 2))/1000000); // 32Mhz
	int ticks = (timer1_num_int * rTCNTB1) + (rTCNTB1 - rTCNTO1);
	int resultado = ticks / Ftimer; // Convertir a microsegundos
	return resultado;
}

/**
 * @brief Parar el temporizador 1
 * @return Tiempo transcurrido en microsegundos
 */
unsigned int timer1_parar(void)
{
	rTCON = (rTCON & ~(0xF << 8)) | (0xA << 8); // Poner a 1010 los bits del 11 al 8 deactiva la cuenta
	return timer1_leer();
}


####################################################################################################################
####################################################################################################################


/* TIMER.H */
/*********************************************************************************************
* Fichero:		timer.h
* Autor:        David Colás y Álvaro Pérez
* Descrip:		Cabeceras de las funciones de control de los timer del s3c44b0x
* Version:
*********************************************************************************************/

#ifndef _TIMER_H_
#define _TIMER_H_

#include "eventos.h"

/*--- Variables visibles del modulo timer.c/timer.h ---*/
volatile int switch_leds;

/*--- Declaracion de funciones visibles del modulo timer.c/timer.h ---*/
void timer0_init(void);
void timer1_2_inicializar(void);
void timer1_empezar(void);
unsigned int timer1_parar(void);
unsigned int timer1_leer(void);

volatile unsigned int tiempo_inicio;
extern volatile int int_count;

extern volatile int fila;
extern volatile int columna;
extern volatile int valor;

extern volatile EstadoSudoku estado_sudoku;

#endif /* _TIMER_H_ */


####################################################################################################################
####################################################################################################################
